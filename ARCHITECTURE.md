# ARCHITECTURE.md

# NixOS System Architecture

This document describes the architectural design of this NixOS configuration repository.
It focuses on structure, responsibility boundaries, and long-term maintainability.

The goal is to make the system easy to understand, modify, and rebuild on any supported machine.

---

## Architectural Principles

- Single entrypoint
- Explicit imports
- Clear separation of concerns
- Hardware-aware but hardware-isolated
- Declarative over imperative
- Repo-based rebuilds (no /etc/nixos)
- Disposable systems by design

This repository assumes the system can be destroyed and rebuilt at any time.

---

## High-Level Design

The architecture follows a layered model:

1. Entry point
2. Host identity
3. Hardware definition
4. Core system
5. Desktop
6. Containers and virtualization
7. Users
8. Maintenance

Each layer only depends on layers below it.

---

## Entrypoint Layer

### configuration.nix

This is the only entrypoint.

Responsibilities:
- Import modules
- Select host profile
- Select hardware configuration
- Define system.stateVersion

Non-responsibilities:
- No logic
- No hardware tuning
- No package lists
- No user configuration

configuration.nix is wiring only.

---

## Host Identity Layer

### profiles/*.nix

Each profile defines:
- networking.hostName
- Bootloader type and configuration

Examples:
- Legacy BIOS (GRUB)
- EFI (systemd-boot)

Only one profile must be imported at a time.

Profiles never define:
- Packages
- Users
- Services

---

## Hardware Layer

### hardware-configuration-*.nix

- Generated by nixos-generate-config
- Disk layout
- Filesystems
- Kernel modules
- CPU microcode

These files must never be edited manually.

### modules/hardware/*.nix

Vendor-specific hardware tuning:
- Firmware
- Wireless drivers
- Kernel blacklists
- Vendor quirks

Hardware modules must not define:
- Desktop environment
- Users
- Applications

---

## Core System Layer

### modules/base.nix

Defines system fundamentals:
- Locale
- Timezone
- Console keymap
- Nix experimental features

### modules/networking.nix

- NetworkManager
- Faster boot by disabling wait-online

### modules/audio.nix

- PipeWire stack
- PulseAudio disabled
- ALSA enabled

### modules/fonts.nix

- System-wide fonts
- Fontconfig defaults

These modules are hardware-agnostic.

---

## Desktop Layer

### modules/desktops/gnome.nix

Defines:
- X server
- Display manager
- Desktop environment
- Wayland configuration
- Portals

### modules/autologin.nix

- Automatic graphical login
- TTY conflict prevention

Only one desktop module should be active.

Desktop modules must not:
- Install developer tools
- Define users
- Manage containers

---

## Application Layer

### modules/system-packages.nix

Defines all global packages:
- Development toolchains
- Editors and IDEs
- CLI utilities
- Browsers
- Container tooling

Packages are:
- System-wide
- Declarative
- Reproducible

No per-user packages are defined here.

---

## Containers and Virtualization Layer

### Docker

- Enabled as a system service
- Boot-time activation
- User group integration

### Podman

- Rootless
- Docker-compatible
- Disabled by default
- Explicit migration path

### K3s

- Single-node Kubernetes
- Server role
- Minimal components
- Firewall-aware

### Libvirt

- QEMU/KVM
- virt-manager support
- Polkit integration

---

## User Layer

### modules/users/borba.nix

Defines:
- User account
- Shell
- Groups
- Sudo rules

Does not manage:
- Dotfiles
- Editor configuration
- Shell configuration

Dotfiles are managed externally via GNU Stow.

---

## Maintenance Layer

Maintenance is intentionally explicit and manual.

There is no hidden automation that mutates the system unexpectedly.

Maintenance tasks are exposed via:
- Makefile
- nixos-rebuild
- nix-collect-garbage

---

## Rebuild Model

- Repository lives in $HOME/nixos-config
- No symlinks to /etc/nixos
- Rebuilds reference repo path explicitly
- System is always built from the repo state

---

## Failure Model

This system assumes failure is acceptable.

If something breaks:
- Roll back generation
- Fix config
- Rebuild

No mutable state is relied upon.

---

## Summary

This architecture favors:
- Clarity over cleverness
- Explicitness over automation
- Rebuildability over persistence

If you can delete the system and rebuild it without fear, the architecture is correct.

Version: v1.0
