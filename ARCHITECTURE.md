# ARCHITECTURE.md

## NixOS System Architecture

This document describes the architectural design of this NixOS configuration repository.  
It explains the structure, responsibilities of each layer, and how components fit together in a **clear, maintainable, and rebuildable** system.

The design assumes that the system can be **destroyed and rebuilt at any time** without loss of reproducibility.

---

## Architectural Principles

- **Single entrypoint** for configuration evaluation
- **Explicit imports** with clear dependency boundaries
- **Separation of concerns** (layers are independent and composable)
- **Hardware-aware but hardware-isolated**
- **Declarative over imperative**
- **Repo-based rebuilds** (no `/etc/nixos` symlinks)
- **Disposable systems by design**

Each layer only depends on the layers below it.

---

## High-Level Layered Model

1. Entrypoint
2. Host identity
3. Hardware definition
4. Core system
5. Desktop
6. Containers and virtualization
7. Application packages
8. Users
9. Maintenance and operations

---

## Entrypoint Layer

### `configuration.nix`

This is the **only entrypoint** used by `nixos-rebuild` or `make switch`.  
It is responsible for:

- Importing all required modules
- Selecting the appropriate host profile
- Selecting the hardware configuration
- Defining `system.stateVersion`

**Do not put logic here.**  
This file should only wire modules together.

It should *never*:

- Contain tuning parameters
- Define package lists
- Define users or services

---

## Host Identity Layer

### `profiles/*.nix`

Each profile defines:

- `networking.hostName`
- Bootloader configuration (EFI or BIOS)
- Host-specific basics (e.g., keyboard layout)

Profiles should *never* define:

- Desktop environment
- Services beyond basics
- Users
- Application packages

---

## Hardware Layer

### `hardware-configuration-*.nix`

Generated by `nixos-generate-config`, this file includes:

- Disk layout
- Filesystems
- Kernel modules
- CPU microcode

These files should **never be edited manually** – they represent the hardware snapshot.

### `modules/hardware/*.nix`

Vendor and model-specific hardware tuning:

- Firmware
- Wireless drivers
- Kernel module blacklists
- Vendor quirks

Hardware modules should not define:

- Desktop environment
- Users
- Applications

---

## Core System Layer

Core modules provide common system foundation and defaults:

### `modules/base.nix`

- Timezone
- Locale
- Console keymap
- Nix experimental features

### `modules/networking.nix`

- NetworkManager
- Faster boot (disables wait-online)

### `modules/audio.nix`

- PipeWire stack
- ALSA enabled, PulseAudio disabled

### `modules/fonts.nix`

- System-wide fonts
- Fontconfig defaults

These modules are **hardware-agnostic**.

---

## Desktop Layer

Desktop modules define a full user experience.

### `modules/desktops/gnome.nix`

Configures:

- X server
- Display manager (GDM)
- GNOME desktop
- Optimized for Wayland
- XDG portals for screen-sharing/Flatpak
- Performance optimizations (excluded bloat packages)

### `modules/desktops/niri/`

Modular configuration for Niri compositor:

- `default.nix` - Main module importing all sub-modules
- `config.nix` - Main config.kdl with include directives
- `input.nix` - Keyboard, mouse, touchpad, tablet settings
- `output.nix` - Monitor configuration
- `layout.nix` - Gaps, borders, focus-ring, cursor, startup apps
- `keybindings.nix` - All keyboard shortcuts (80+)
- `window-rules.nix` - App-specific window rules
- `animations.nix` - Spring-based smooth animations
- `waybar.nix` - Status bar with system monitoring
- `mako.nix` - Notification daemon
- `fuzzel.nix` - Application launcher

### `modules/desktops/i3.nix`

Configures:

- i3 tiling window manager (X11)
- Suitable for low-resource machines

### `modules/autologin.nix`

- Automatic graphical login helper (optional)
- Prevents TTY conflicts

**Only one desktop should be enabled per host.**  
Desktop modules should not define:

- Users
- Developers tooling
- Containers

---

## Application Package Layer

### `modules/system-packages.nix`

Defines all **global system-wide packages**, including:

- Development toolchains (Go, Rust, C/C++)
- Editors and IDEs
- CLI utilities
- Browsers
- Container tooling

Packages are:

- System-wide
- Declarative
- Reproducible

No per-user packages are defined here.

---

## Containers and Virtualization Layer

This layer groups container runtimes and virtualization services.

- **Docker** – system service, enabled optionally via feature flags
- **Podman** – rootless, docker-compatible
- **K3s** – single-node Kubernetes
- **Libvirt/QEMU** – virtualization, virt-manager and polkit integration

Feature flags ensure these services are only enabled when requested.

---

## User Layer

### `modules/users/borba.nix`

Defines:

- User account
- Default shell
- Group memberships
- Sudo rules

Does not manage:

- Dotfiles
- Editor config  
  (These are managed externally, e.g., via GNU Stow)

---

## Maintenance & Operations Layer

Maintenance is **explicit and manual**.

There is no hidden automation that mutates state:

- System operations via `Makefile`
- `nixos-rebuild`
- Garbage collection via `nix-collect-garbage`
- Troubleshooting with scripts

---

## Rebuild Model

- Repository resides in `$HOME/nixos-config`
- No symlinks to `/etc/nixos`
- Builds reference this repo path explicitly
- The system is always built from **the repository state**

This ensures reproducible and predictable system rebuilds.

---

## Failure Model

This system assumes failure is acceptable:

- If something breaks:
  - Roll back to previous generation
  - Fix the configuration
  - Rebuild

No mutable state is relied upon.

---

## Summary

This architecture favors:

- **Clarity over cleverness**
- **Explicitness over automation**
- **Rebuildability over persistence**

If you can delete the system and rebuild it without fear, the architecture is correct.

Version: v1.0
